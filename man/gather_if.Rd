% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gather_if.R
\name{gather_if}
\alias{gather_if}
\title{Gather selected variables into key-value pairs.}
\usage{
gather_if(data, .predicate, key = "key", value = "value", ...,
  na.rm = FALSE, convert = FALSE, factor_key = FALSE)
}
\arguments{
\item{data}{A data frame.}

\item{.predicate}{A predicate function to be applied to the columns
or a logical vector. The variables for which \code{.predicate} is or
returns TRUE are gathered. This argument is passed to
`rlang::as_function()``and thus supports quosure-style lambda
functions and strings representing function names.}

\item{key}{Names of new key and value columns, as strings or
symbols.

This argument is passed by expression and supports
\link[rlang:quasiquotation]{quasiquotation} (you can unquote strings
and symbols). The name is captured from the expression with
\code{\link[rlang:quo_name]{rlang::quo_name()}} (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).}

\item{value}{Names of new key and value columns, as strings or
symbols.

This argument is passed by expression and supports
\link[rlang:quasiquotation]{quasiquotation} (you can unquote strings
and symbols). The name is captured from the expression with
\code{\link[rlang:quo_name]{rlang::quo_name()}} (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).}

\item{...}{An additional selection of columns after \code{.predicate}.
If empty, all variables selected by \code{.predicate} are selected.
You can supply bare variable names, select all variables between
x and z with \code{x:z}, exclude y with \code{-y}. For more options, see
the \code{\link[dplyr:select]{dplyr::select()}} documentation. See also the section on
selection rules in \code{gather}.}

\item{na.rm}{If \code{TRUE}, will remove rows from output where the
value column in \code{NA}.}

\item{convert}{If \code{TRUE} will automatically run
\code{\link[=type.convert]{type.convert()}} on the key column. This is useful if the column
names are actually numeric, integer, or logical.}

\item{factor_key}{If \code{FALSE}, the default, the key values will be
stored as a character vector. If \code{TRUE}, will be stored as a factor,
which preserves the original ordering of the columns.}
}
\description{
A scoped variant of \code{gather()} operate on a selection of variables.
}
\examples{
library(dplyr)
# From http://stackoverflow.com/questions/1181060
stocks <- tibble(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)

gather_if(stocks, is.numeric, stock, price)
stocks \%>\% gather_if(is.numeric, stock, price)
# same result by gather
gather(stocks, stock, price, -time)

# get first observation for each Species in iris data -- base R
mini_iris <- iris[c(1:3, 51:53, 101:103), ]
# gather Sepal.Length, Sepal.Width, Petal.Length, Petal.Width
gather_if(mini_iris, is.numeric, key = flower_att, value = measurement)
# same result by gather
gather(mini_iris, key = flower_att, value = measurement, -Species)
# in case Sepal.Length should be kept as a column,
gather_if(mini_iris, is.numeric, key = flower_att, value = measurement, -Sepal.Length)

}
