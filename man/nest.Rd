% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nest.R
\name{nest}
\alias{nest}
\title{Nest repeated values in a list-column of data frames}
\usage{
nest(.data, ..., .key = "DEPRECATED")
}
\arguments{
\item{.data}{A data frame.}

\item{...}{Name-variable pairs of the form \code{new_col = c(col1, col2, col3)},
that describe how you wish to nest existing columns into new columns.
The right hand side can be any expression supported by tidyselect.

\strong{Deprecated}: previously you could write \code{df \%>\% nest(x, y, z)},
now you should rewrite this as \code{df \%>\% nest(data = c(x, y, z))}.}

\item{.key}{\strong{Deprecated}: No longer needed because of the updated \code{...}
syntax.}
}
\description{
Nesting is implicitly a summarising operation: you get one row defined
by the grouping defined by the non-nested columns. This is useful in
conjunction with other summaries that work with whole datasets, most
notably models, as described in \url{https://r4ds.had.co.nz/many-models.html}.

Learn more in \code{vignette("nesting")}.
}
\section{Grouped data frames}{

\code{nest()} specify the columns to be nested; i.e. the columns that will appear
in the inner data frame. Alternatively, you \code{nest()} a grouped data frame
created by \code{\link[dplyr:group_by]{dplyr::group_by()}}. Here the grouping variables will remain
in the outer data frame, and all other variables will go into the inner
data frame. The result will be an ungrouped tibble, where each row
represents a group in the input.
}

\examples{
df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
# Note that we get one row of output for each unique combination of
# non-chopped variables
df \%>\% nest(data = c(y, z))
# cf nest
df \%>\% chop(c(y, z))

iris \%>\% nest(data = -Species)
chickwts \%>\% nest(data = weight)

# Nesting a grouped data frame nests all variables apart from the group vars
fish_encounters \%>\%
  dplyr::group_by(fish) \%>\%
  nest()
}
\seealso{
\code{\link[=unnest]{unnest()}} for the inverse operation.
}
